"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
/**
 * Parse request headers for checking its signature.
 *
 * @param req The base request
 */
exports.parseHeaders = (req, timeout) => {
    const timestamp = req.headers["x-request-timestamp"];
    const signature = req.headers["x-request-signature"];
    const parsedTimestamp = timestamp ? parseInt(timestamp, 10) : undefined;
    // Incorrect request timestamp signature
    if (!timestamp || isNaN(parsedTimestamp)) {
        return { signature };
    }
    // Check if timestamp has already expired
    const hasExpired = parsedTimestamp < Date.now() - timeout;
    return {
        signature,
        timestamp: !hasExpired ? parsedTimestamp : undefined
    };
};
/**
 * Generate a HMAC SHA256 signature from request payload and secret string.
 *
 * @param req The base request
 * @param secret The secret to be used in the encryption
 */
exports.generateSignaturePayload = (req, secret, signedBodyMethods) => {
    const items = [req.method, req.url, req.headers["x-request-timestamp"]];
    const shouldVerifyBody = signedBodyMethods.indexOf(req.method.toUpperCase()) >= 0;
    if (shouldVerifyBody) {
        // Add request body to signature
        items.push(JSON.stringify(req.body));
    }
    if (!secret) {
        throw new Error("Invalid secret for computing request signature");
    }
    return crypto.createHmac("sha256", secret).update(items.join(",")).digest("hex");
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL2xpYi91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaUNBQWlDO0FBR2pDOzs7O0dBSUc7QUFDVSxRQUFBLFlBQVksR0FBRyxDQUFDLEdBQWdCLEVBQUUsT0FBZSxFQUE2QyxFQUFFO0lBQzNHLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQVcsQ0FBQztJQUMvRCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFXLENBQUM7SUFDL0QsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBbUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBRWxGLHdDQUF3QztJQUN4QyxJQUFJLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFBRTtRQUN4QyxPQUFPLEVBQUUsU0FBUyxFQUFFLENBQUM7S0FDdEI7SUFFRCx5Q0FBeUM7SUFDekMsTUFBTSxVQUFVLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFFMUQsT0FBTztRQUNMLFNBQVM7UUFDVCxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsU0FBUztLQUNyRCxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDVSxRQUFBLHdCQUF3QixHQUFHLENBQUMsR0FBZ0IsRUFBRSxNQUFjLEVBQUUsaUJBQXFDLEVBQUUsRUFBRTtJQUNsSCxNQUFNLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQztJQUN4RSxNQUFNLGdCQUFnQixHQUFHLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFdBQVcsRUFBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXpGLElBQUksZ0JBQWdCLEVBQUU7UUFDcEIsZ0NBQWdDO1FBQ2hDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUN0QztJQUVELElBQUksQ0FBQyxNQUFNLEVBQUU7UUFDWCxNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7S0FDbkU7SUFFRCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25GLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNyeXB0byBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgeyBCYXNlUmVxdWVzdCB9IGZyb20gXCJ0cy1mcmFtZXdvcmtcIjtcblxuLyoqXG4gKiBQYXJzZSByZXF1ZXN0IGhlYWRlcnMgZm9yIGNoZWNraW5nIGl0cyBzaWduYXR1cmUuXG4gKlxuICogQHBhcmFtIHJlcSBUaGUgYmFzZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUhlYWRlcnMgPSAocmVxOiBCYXNlUmVxdWVzdCwgdGltZW91dDogbnVtYmVyKTogeyB0aW1lc3RhbXA/OiBudW1iZXI7IHNpZ25hdHVyZTogc3RyaW5nIH0gPT4ge1xuICBjb25zdCB0aW1lc3RhbXAgPSByZXEuaGVhZGVyc1tcIngtcmVxdWVzdC10aW1lc3RhbXBcIl0gYXMgc3RyaW5nO1xuICBjb25zdCBzaWduYXR1cmUgPSByZXEuaGVhZGVyc1tcIngtcmVxdWVzdC1zaWduYXR1cmVcIl0gYXMgc3RyaW5nO1xuICBjb25zdCBwYXJzZWRUaW1lc3RhbXAgPSB0aW1lc3RhbXAgPyBwYXJzZUludCh0aW1lc3RhbXAgYXMgc3RyaW5nLCAxMCkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gSW5jb3JyZWN0IHJlcXVlc3QgdGltZXN0YW1wIHNpZ25hdHVyZVxuICBpZiAoIXRpbWVzdGFtcCB8fCBpc05hTihwYXJzZWRUaW1lc3RhbXApKSB7XG4gICAgcmV0dXJuIHsgc2lnbmF0dXJlIH07XG4gIH1cblxuICAvLyBDaGVjayBpZiB0aW1lc3RhbXAgaGFzIGFscmVhZHkgZXhwaXJlZFxuICBjb25zdCBoYXNFeHBpcmVkID0gcGFyc2VkVGltZXN0YW1wIDwgRGF0ZS5ub3coKSAtIHRpbWVvdXQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmUsXG4gICAgdGltZXN0YW1wOiAhaGFzRXhwaXJlZCA/IHBhcnNlZFRpbWVzdGFtcCA6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIEhNQUMgU0hBMjU2IHNpZ25hdHVyZSBmcm9tIHJlcXVlc3QgcGF5bG9hZCBhbmQgc2VjcmV0IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gcmVxIFRoZSBiYXNlIHJlcXVlc3RcbiAqIEBwYXJhbSBzZWNyZXQgVGhlIHNlY3JldCB0byBiZSB1c2VkIGluIHRoZSBlbmNyeXB0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZVNpZ25hdHVyZVBheWxvYWQgPSAocmVxOiBCYXNlUmVxdWVzdCwgc2VjcmV0OiBzdHJpbmcsIHNpZ25lZEJvZHlNZXRob2RzOiAoJ1BPU1QnIHwgJ1BVVCcpW10pID0+IHtcbiAgY29uc3QgaXRlbXMgPSBbcmVxLm1ldGhvZCwgcmVxLnVybCwgcmVxLmhlYWRlcnNbXCJ4LXJlcXVlc3QtdGltZXN0YW1wXCJdXTtcbiAgY29uc3Qgc2hvdWxkVmVyaWZ5Qm9keSA9IHNpZ25lZEJvZHlNZXRob2RzLmluZGV4T2YocmVxLm1ldGhvZC50b1VwcGVyQ2FzZSgpIGFzIGFueSkgPj0gMDtcblxuICBpZiAoc2hvdWxkVmVyaWZ5Qm9keSkge1xuICAgIC8vIEFkZCByZXF1ZXN0IGJvZHkgdG8gc2lnbmF0dXJlXG4gICAgaXRlbXMucHVzaChKU09OLnN0cmluZ2lmeShyZXEuYm9keSkpO1xuICB9XG5cbiAgaWYgKCFzZWNyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlY3JldCBmb3IgY29tcHV0aW5nIHJlcXVlc3Qgc2lnbmF0dXJlXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHNlY3JldCkudXBkYXRlKGl0ZW1zLmpvaW4oXCIsXCIpKS5kaWdlc3QoXCJoZXhcIik7XG59O1xuIl19