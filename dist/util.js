"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto = require("crypto");
/**
 * Parse request headers for checking its signature.
 *
 * @param req The base request
 */
exports.parseHeaders = (req, timeout) => {
    const timestamp = req.headers["x-request-timestamp"];
    const signature = req.headers["x-request-signature"];
    const parsedTimestamp = timestamp ? parseInt(timestamp, 10) : undefined;
    // Incorrect request timestamp signature
    if (!timestamp || isNaN(parsedTimestamp)) {
        return { signature };
    }
    // Check if timestamp has already expired
    const hasExpired = parsedTimestamp < Date.now() - timeout;
    return {
        signature,
        timestamp: !hasExpired ? parsedTimestamp : undefined
    };
};
/**
 * Generate a HMAC SHA256 signature from request payload and secret string.
 *
 * @param req The base request
 * @param secret The secret to be used in the encryption
 */
exports.generateSignaturePayload = (req, secret, signedBodyMethods = []) => {
    const items = [req.method, req.url, req.headers["x-request-timestamp"]];
    const shouldVerifyBody = signedBodyMethods.indexOf(req.method.toUpperCase()) >= 0;
    if (shouldVerifyBody) {
        // Add request body to signature
        items.push(JSON.stringify(req.body));
    }
    if (!secret) {
        throw new Error("Invalid computed signature secret");
    }
    return crypto.createHmac("sha256", secret).update(items.join(",")).digest("hex");
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL2xpYi91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsaUNBQWlDO0FBR2pDOzs7O0dBSUc7QUFDVSxRQUFBLFlBQVksR0FBRyxDQUFDLEdBQWdCLEVBQUUsT0FBZSxFQUE2QyxFQUFFO0lBQzNHLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQVcsQ0FBQztJQUMvRCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLHFCQUFxQixDQUFXLENBQUM7SUFDL0QsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsU0FBbUIsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBRWxGLHdDQUF3QztJQUN4QyxJQUFJLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFBRTtRQUN4QyxPQUFPLEVBQUUsU0FBUyxFQUFFLENBQUM7S0FDdEI7SUFFRCx5Q0FBeUM7SUFDekMsTUFBTSxVQUFVLEdBQUcsZUFBZSxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxPQUFPLENBQUM7SUFFMUQsT0FBTztRQUNMLFNBQVM7UUFDVCxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsU0FBUztLQUNyRCxDQUFDO0FBQ0osQ0FBQyxDQUFDO0FBRUY7Ozs7O0dBS0c7QUFDVSxRQUFBLHdCQUF3QixHQUFHLENBQUMsR0FBZ0IsRUFBRSxNQUFjLEVBQUUsb0JBQXdDLEVBQUUsRUFBRSxFQUFFO0lBQ3ZILE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLE1BQU0sZ0JBQWdCLEdBQUcsaUJBQWlCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFekYsSUFBSSxnQkFBZ0IsRUFBRTtRQUNwQixnQ0FBZ0M7UUFDaEMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0tBQ3RDO0lBRUQsSUFBSSxDQUFDLE1BQU0sRUFBRTtRQUNYLE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQztLQUN0RDtJQUVELE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkYsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3J5cHRvIGZyb20gXCJjcnlwdG9cIjtcbmltcG9ydCB7IEJhc2VSZXF1ZXN0IH0gZnJvbSBcInRzLWZyYW1ld29ya1wiO1xuXG4vKipcbiAqIFBhcnNlIHJlcXVlc3QgaGVhZGVycyBmb3IgY2hlY2tpbmcgaXRzIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gcmVxIFRoZSBiYXNlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlSGVhZGVycyA9IChyZXE6IEJhc2VSZXF1ZXN0LCB0aW1lb3V0OiBudW1iZXIpOiB7IHRpbWVzdGFtcD86IG51bWJlcjsgc2lnbmF0dXJlOiBzdHJpbmcgfSA9PiB7XG4gIGNvbnN0IHRpbWVzdGFtcCA9IHJlcS5oZWFkZXJzW1wieC1yZXF1ZXN0LXRpbWVzdGFtcFwiXSBhcyBzdHJpbmc7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHJlcS5oZWFkZXJzW1wieC1yZXF1ZXN0LXNpZ25hdHVyZVwiXSBhcyBzdHJpbmc7XG4gIGNvbnN0IHBhcnNlZFRpbWVzdGFtcCA9IHRpbWVzdGFtcCA/IHBhcnNlSW50KHRpbWVzdGFtcCBhcyBzdHJpbmcsIDEwKSA6IHVuZGVmaW5lZDtcblxuICAvLyBJbmNvcnJlY3QgcmVxdWVzdCB0aW1lc3RhbXAgc2lnbmF0dXJlXG4gIGlmICghdGltZXN0YW1wIHx8IGlzTmFOKHBhcnNlZFRpbWVzdGFtcCkpIHtcbiAgICByZXR1cm4geyBzaWduYXR1cmUgfTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHRpbWVzdGFtcCBoYXMgYWxyZWFkeSBleHBpcmVkXG4gIGNvbnN0IGhhc0V4cGlyZWQgPSBwYXJzZWRUaW1lc3RhbXAgPCBEYXRlLm5vdygpIC0gdGltZW91dDtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZSxcbiAgICB0aW1lc3RhbXA6ICFoYXNFeHBpcmVkID8gcGFyc2VkVGltZXN0YW1wIDogdW5kZWZpbmVkXG4gIH07XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgSE1BQyBTSEEyNTYgc2lnbmF0dXJlIGZyb20gcmVxdWVzdCBwYXlsb2FkIGFuZCBzZWNyZXQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSByZXEgVGhlIGJhc2UgcmVxdWVzdFxuICogQHBhcmFtIHNlY3JldCBUaGUgc2VjcmV0IHRvIGJlIHVzZWQgaW4gdGhlIGVuY3J5cHRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlU2lnbmF0dXJlUGF5bG9hZCA9IChyZXE6IEJhc2VSZXF1ZXN0LCBzZWNyZXQ6IHN0cmluZywgc2lnbmVkQm9keU1ldGhvZHM6ICgnUE9TVCcgfCAnUFVUJylbXSA9IFtdKSA9PiB7XG4gIGNvbnN0IGl0ZW1zID0gW3JlcS5tZXRob2QsIHJlcS51cmwsIHJlcS5oZWFkZXJzW1wieC1yZXF1ZXN0LXRpbWVzdGFtcFwiXV07XG4gIGNvbnN0IHNob3VsZFZlcmlmeUJvZHkgPSBzaWduZWRCb2R5TWV0aG9kcy5pbmRleE9mKHJlcS5tZXRob2QudG9VcHBlckNhc2UoKSBhcyBhbnkpID49IDA7XG5cbiAgaWYgKHNob3VsZFZlcmlmeUJvZHkpIHtcbiAgICAvLyBBZGQgcmVxdWVzdCBib2R5IHRvIHNpZ25hdHVyZVxuICAgIGl0ZW1zLnB1c2goSlNPTi5zdHJpbmdpZnkocmVxLmJvZHkpKTtcbiAgfVxuXG4gIGlmICghc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb21wdXRlZCBzaWduYXR1cmUgc2VjcmV0XCIpO1xuICB9XG5cbiAgcmV0dXJuIGNyeXB0by5jcmVhdGVIbWFjKFwic2hhMjU2XCIsIHNlY3JldCkudXBkYXRlKGl0ZW1zLmpvaW4oXCIsXCIpKS5kaWdlc3QoXCJoZXhcIik7XG59O1xuIl19